<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Kubernetes client-go: Updating and rolling back a deployment - de1ux
    </title>
    <link rel="alternate" href="http://localhost:8080/feed.xml" type="application/rss+xml" title="Learning how to blog in 2018">
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="/css/main.css">
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <h1>Kubernetes client-go: Updating and rolling back a deployment</h1>
        <p class="author">Written by <span class="author"><a href="mailto:evans.nathan.j@gmail.com">Nathan Evans</a></span>
        </p>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <section class="content"><p><span class="more"></span></p>
<h3 id="warning"><span class="caps">WARNING</span></h3>
<p>All of this was written during version 6.0 of the Kubernetes client. The information here may be out of date:&nbsp;ymmv</p>
<h3 id="picking-the-right-kubernetes-client-version">Picking the right Kubernetes client&nbsp;version</h3>
<p>Kubernetes provides an excellent <a href="https://github.com/kubernetes/client-go/tree/v6.0.0#compatibility-matrix">compatibility matrix</a> to help target the right client version for communicating with the&nbsp;cluster.</p>
<p><strong><em>Don’t</em></strong> worry about picking a minor version higher than your current Kubernetes <span class="caps">API</span> minor version; I targeted two versions ahead of the API server and all tested out&nbsp;well.</p>
<p><strong><em>Do</em></strong> worry if you plan on exercising non-core/alpha client features that your cluster might not&nbsp;support.</p>
<h3 id="installing-k8s-io-client-go">Installing&nbsp;k8s.io/client-go</h3>
<p>Currently, the client does not play well with <a href="https://github.com/golang/dep">dep</a>, but the authors have done a great writeup about the <a href="https://github.com/kubernetes/client-go/blob/master/INSTALL.md">install options currently available</a>.</p>
<p>Here’s a quick and dirty build script ganked from their&nbsp;<span class="caps">INSTALL</span>.md:</p>
<pre><code class="lang-bash">go get -v github.com/tools/godep

go get -v k8s.io/client-go/...
<span class="built_in">pushd</span> <span class="variable">$<span class="caps">GOPATH</span></span>/src/k8s.io/client-go
git checkout v6.0.0
godep restore ./...
<span class="built_in">popd</span>
</code></pre>
<h3 id="create-a-kubernetes-clientset">Create a Kubernetes&nbsp;clientset</h3>
<p>It’s likely you have a <code>$HOME/.kube/config</code> already from playing with <code>kubectl</code> and minikube, making it trivial to generate a client (or as Kubernetes calls it, a <code>clientset</code>).</p>
<pre><code class="lang-go">config, err := clientcmd.BuildConfigFromFlags(<span class="string">""</span>, filepath.Join(homedir.HomeDir(), <span class="string">".kube"</span>, <span class="string">"config"</span>))
<span class="keyword">if</span> err != <span class="literal">nil</span> {
    <span class="built_in">panic</span>(err)
}

clientSet, err := kubernetes.NewForConfig(config)
<span class="keyword">if</span> err != <span class="literal">nil</span> {
    <span class="built_in">panic</span>(err)
}
</code></pre>
<h3 id="getting-an-existing-deployment">Getting an existing&nbsp;deployment</h3>
<p>Before we start a new deployment, we first need to assert that an existing deployment is running and in a good&nbsp;state.</p>
<p>Here is a <span class="caps">YAML</span> of redis I’ve been toying around with in <code>kubectl</code> that will provide the initial&nbsp;containers.</p>
<pre><code class="lang-yaml"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span> <span class="comment"># for versions before 1.8.0 use apps/v1beta1</span>
<span class="attr">kind:</span> <span class="string">Deployment</span>
<span class="attr">metadata:</span>
<span class="attr">  name:</span> <span class="string">redis</span>
<span class="attr">spec:</span>
<span class="attr">  selector:</span>
<span class="attr">    matchLabels:</span>
<span class="attr">      app:</span> <span class="string">redis</span>
<span class="attr">  replicas:</span> <span class="number">2</span> <span class="comment"># tells deployment to run 2 pods matching the template</span>
<span class="attr">  template:</span> <span class="comment"># create pods using pod definition in this template</span>
<span class="attr">    metadata:</span>
      <span class="comment"># unlike pod-nginx.yaml, the name is not included in the meta data as a unique name is</span>
      <span class="comment"># generated from the deployment name</span>
<span class="attr">      labels:</span>
<span class="attr">        app:</span> <span class="string">redis</span>
<span class="attr">    spec:</span>
<span class="attr">      containers:</span>
<span class="attr">      - name:</span> <span class="string">redis</span>
<span class="attr">        image:</span> <span class="attr">redis:3</span>
<span class="attr">        ports:</span>
<span class="attr">        - containerPort:</span> <span class="number">6379</span>
</code></pre>
<pre><code class="lang-bash">$ kubectl create -f deployments/redis.yaml
</code></pre>
<p>Now we’ll use Go to verify the redis deployment exists and all replicas are in a <code>running</code> state.</p>
<pre><code class="lang-go">dClient := clientSet.ExtensionsV1beta1().Deployments(<span class="string">"default"</span>)

<span class="comment">// Get a copy of the current deployment</span>
originalDeployment, err := dClient.Get(<span class="string">"redis"</span>, metav1.GetOptions{})
<span class="keyword">if</span> err != <span class="literal">nil</span> {
    <span class="built_in">panic</span>(err)
}

<span class="comment">// Verify the current containers in the pod are running</span>
<span class="keyword">if</span> allRunning, err := podContainersRunning(clientSet, <span class="string">"redis"</span>); !(allRunning &amp;&amp; err == <span class="literal">nil</span>) {
    <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"Not all containers are currently running, or err: %s"</span>, err))
}
</code></pre>
<p>Since we’ve asserted the existing redis deploy is running and available, we now know&nbsp;that</p>
<ul>
<li>any issues during our deploy are likely caused by us, and not the existing&nbsp;containers</li>
<li>there is a succesful deploy to rollback&nbsp;to</li>
</ul>
<h3 id="updating-a-deployment">Updating a&nbsp;deployment</h3>
<p>Updating a deployment is as easy as updating the fields we’re interested in and resubmitting it to the cluster. The redis tag is intentionally incorrect to simulate an unhealthy&nbsp;deploy.</p>
<pre><code class="lang-go">dClient := client.ExtensionsV1beta1().Deployments(<span class="string">"default"</span>)

retryErr := retry.RetryOnConflict(retry.DefaultRetry, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> {
    <span class="comment">// Assumes you've already deployed redis before to the cluster</span>
    result, getErr := dClient.Get(<span class="string">"redis"</span>, metav1.GetOptions{})
    <span class="keyword">if</span> getErr != <span class="literal">nil</span> {
        <span class="built_in">panic</span>(fmt.Errorf(<span class="string">"Failed to get latest version of redis: %s"</span>, getErr))
    }

    result.Spec.Template.Spec.Containers[<span class="number">0</span>].Image = <span class="string">"redis:doesntexist"</span>
    _, updateErr := dClient.Update(result)
    <span class="keyword">return</span> updateErr
})

<span class="keyword">if</span> retryErr != <span class="literal">nil</span> {
    <span class="built_in">panic</span>(retryErr)
}
</code></pre>
<p>Every deployment object returned from client-go includes a resource version indicating the version that cluster has seen. If the redis deployment is updated during <em>our</em> attempt to update the same redis deployment, the server will reject us because our resource versions&nbsp;conflict.</p>
<p>Thankfully, client-go provides a <code>RetryOnConflict</code> utility that debounces conflict errors. On each retry of the deployment, we get a fresh copy of the cluster’s current redis deployment and apply our deployment operation over top of&nbsp;it.</p>
<p>From the examples for <code>RetryOnConflict</code></p>
<pre><code>//    You have two options to Update() this Deployment:
//
//    1. Modify the &quot;deployment&quot; variable and call: Update(deployment).
//       This works like the &quot;kubectl replace&quot; command and it overwrites/loses changes
//       made by other clients between you Create() and Update() the object.
//    2. Modify the &quot;result&quot; returned by Get() and retry Update(result) until
//       you no longer get a conflict error. This way, you can preserve changes made
//       by other clients between Create() and Update(). This is implemented below
//           using the retry utility package included with client-go. (RECOMMENDED)
//
// More Info:
// https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency
</code></pre><p>Thinking of deploys as operations on top of deployment objects naturally leads to abstracting the <em>contents</em> of the operation away from the <em>act</em> of&nbsp;deploying.</p>
<pre><code class="lang-go"><span class="keyword">if</span> err := deploy(dClient, <span class="string">"redis"</span>, <span class="function"><span class="keyword">func</span><span class="params">(deployment *apiv1.Deployment)</span></span> {
    deployment.Spec.Template.Spec.Containers[<span class="number">0</span>].Image = <span class="string">"redis:doesntexist"</span>
}); err != <span class="literal">nil</span> {
    <span class="built_in">panic</span>(err)
}

err = waitForPodContainersRunning(clientSet, <span class="string">"redis"</span>)
<span class="keyword">if</span> err == <span class="literal">nil</span> {
    <span class="built_in">println</span>(<span class="string">"Deploy successful"</span>)
}
</code></pre>
<pre><code class="lang-go"><span class="function"><span class="keyword">func</span> <span class="title">deploy</span><span class="params">(dClient v1.DeploymentInterface, app <span class="keyword">string</span>, op <span class="keyword">func</span>(deployment *apiv1.Deployment)</span>) <span class="title">error</span></span> {
    <span class="keyword">return</span> retry.RetryOnConflict(retry.DefaultRetry, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> {
        result, err := dClient.Get(app, metav1.GetOptions{})
        <span class="keyword">if</span> err != <span class="literal">nil</span> {
            <span class="built_in">panic</span>(fmt.Errorf(<span class="string">"Failed to get latest version of %s: %s"</span>, app, err))
        }

        op(result)

        _, updateErr := dClient.Update(result)
        <span class="keyword">return</span> updateErr
    })
}
</code></pre>
<h3 id="rolling-back-a-deployment">Rolling back a&nbsp;deployment</h3>
<p>If a deployment fails, rolling back the operation requires reversing the fields modified during the deployment operation and resubmitting the&nbsp;deploy.</p>
<pre><code class="lang-go"><span class="comment">// Try rolling back</span>
<span class="keyword">if</span> err := deploy(dClient, <span class="string">"redis"</span>, <span class="function"><span class="keyword">func</span><span class="params">(deployment *apiv1.Deployment)</span></span> {
    deployment.Spec.Template.Spec.Containers[<span class="number">0</span>].Image = originalDeployment.Spec.Template.Spec.Containers[<span class="number">0</span>].Image
}); err != <span class="literal">nil</span> {
    <span class="built_in">panic</span>(err)
}

err = waitForPodContainersRunning(clientSet, <span class="string">"redis"</span>)
<span class="keyword">if</span> err != <span class="literal">nil</span> {
    <span class="built_in">panic</span>(err)
}
<span class="built_in">println</span>(<span class="string">"Rolled back successfully!"</span>)
</code></pre>
<h3 id="notes">Notes</h3>
<ul>
<li><a href="https://github.com/de1ux/kubernetes_exercises/blob/master/exercises/deploy.go">Exercise&nbsp;code</a></li>
<li><a href="https://github.com/kubernetes/client-go/tree/v6.0.0/examples">Client-go&nbsp;examples</a></li>
</ul>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/">&laquo; Full blog</a></div>
        <section class="about"><p><a href="https://github.com/de1ux"><img class="image-float-center" src="/images/github.png" height=24 width=24 /></a></p>
<p><a href="mailto:evans.nathan.j@gmail.com"><img class="image-float-center" src="/images/email.png" height=24 width=24 /></a></p>
<p><a href="https://linkedin.com/in/de1ux/"><img class="image-float-center" src="/images/linkedin.png" height=24 width=24 /></a></p>

        </section>
        <section class="copy">
          <p>&copy; 2018 de1ux.com &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>